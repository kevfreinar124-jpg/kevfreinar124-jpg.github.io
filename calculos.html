<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <link rel="shortcut icon" href="./imagenes/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cálculos - Métodos Numéricos</title>
  <style>
    /* ====== RESET & BASE ====== */
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
    }

    html, body { 
      height: 100%; 
    }

    body {
      font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #f6fbff 0%, #eef6ff 100%);
      color: #08304b;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      line-height: 1.6;
    }

    /* ====== HEADER ====== */
    header {
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      color: #fff;
      padding: 1.6rem 1rem;
      text-align: center;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 6px 18px rgba(37, 17, 103, 0.12);
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header h1 { 
      font-size: 2.2rem; 
      letter-spacing: 0.4px; 
      margin: 0;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    header p { 
      font-size: 1rem; 
      opacity: 0.92; 
      margin-top: 0.5rem;
      max-width: 600px;
    }

    /* ====== NAV ====== */
    nav { 
      background: linear-gradient(135deg, #00509d, #003f88);
      padding: 0.8rem 0;
      width: 100%;
    }

    nav ul {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      padding: 0.6rem 1rem;
      flex-wrap: wrap;
      list-style: none;
      margin: 0;
    }

    nav a {
      color: #fff;
      text-decoration: none;
      padding: 0.7rem 1.2rem;
      border-radius: 12px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(4px);
      position: relative;
      overflow: hidden;
    }

    nav a.activo {
      background: #a9d6e5;
      color: #0b3b67;
    }

    /* Menu toggle para móviles */
    .menu-toggle {
      position: absolute;
      right: 1rem;
      top: 1rem;
      font-size: 1.8rem;
      background: rgba(255, 255, 255, 0.15);
      color: #fff;
      padding: 0.4rem 0.8rem;
      border-radius: 8px;
      display: none;
      cursor: pointer;
      z-index: 101;
      border: none;
    }

    /* ====== MAIN LAYOUT ====== */
    main { 
      max-width: 1200px; 
      margin: 2rem auto; 
      padding: 0 1rem 3rem; 
    }

    /* ====== INTRO CARD ====== */
    .intro-card {
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      border-radius: 18px;
      padding: 2.5rem;
      box-shadow: 0 10px 30px rgba(9, 30, 63, 0.08);
      text-align: center;
      margin-bottom: 2.5rem;
      position: relative;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
      border: 1px solid rgba(37, 117, 252, 0.1);
    }

    .intro-card h2, 
    .intro-card h3 { 
      color: #0b3b67; 
      font-size: 2rem; 
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .intro-card p { 
      color: #27404f; 
      font-size: 1.1rem; 
      max-width: 900px; 
      margin: auto;
      line-height: 1.7;
    }

    /* ====== FORMULARIOS DE CÁLCULO ====== */
    .calculos-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 2rem;
      max-width: 1100px;
      margin: 2rem auto;
      padding: 0 1rem;
    }

    .calculo-card {
      background: linear-gradient(180deg, #ffffff, #f3f9ff);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 8px 20px rgba(3, 30, 60, 0.08);
      display: flex;
      flex-direction: column;
      gap: 1.2rem;
      border: 1px solid rgba(37, 117, 252, 0.1);
      position: relative;
      overflow: hidden;
    }

    .calculo-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: linear-gradient(90deg, #2575fc, #6a11cb);
    }

    .calculo-icono {
      font-size: 2.5rem;
      background: linear-gradient(90deg, #2575fc, #6a11cb);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      align-self: center;
    }

    .calculo-card h3 { 
      font-size: 1.4rem; 
      color: #052b43; 
      margin-top: 0.5rem;
      font-weight: 700;
      text-align: center;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: #08304b;
    }

    .form-group input, 
    .form-group textarea, 
    .form-group select {
      width: 100%;
      padding: 0.8rem;
      border: 1px solid #d0e3ff;
      border-radius: 8px;
      font-size: 1rem;
      background: #f8fbff;
    }

    .form-group textarea {
      min-height: 100px;
      resize: vertical;
    }

    .btn-calcular {
      padding: 1rem 2rem;
      background: linear-gradient(90deg, #2575fc, #6a11cb);
      color: #fff;
      border: none;
      border-radius: 50px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 6px 15px rgba(37, 117, 252, 0.3);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      font-size: 1.1rem;
      width: 100%;
      margin-top: 1rem;
    }

    /* ====== VENTANAS FLOTANTES ====== */
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
    }

    .modal-contenido {
      background: linear-gradient(180deg, #ffffff, #fbfdff);
      margin: 2% auto;
      padding: 0;
      border-radius: 16px;
      width: 90%;
      max-width: 800px;
      max-height: 90vh;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      animation: modalAppear 0.3s ease-out;
      display: flex;
      flex-direction: column;
    }

    @keyframes modalAppear {
      from {
        opacity: 0;
        transform: translateY(-50px) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .modal-header {
      background: linear-gradient(135deg, #2575fc, #6a11cb);
      color: white;
      padding: 1.5rem 2rem;
      border-radius: 16px 16px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h3 {
      margin: 0;
      font-size: 1.4rem;
    }

    .cerrar {
      color: white;
      font-size: 2rem;
      font-weight: bold;
      cursor: pointer;
      background: none;
      border: none;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .cerrar:hover {
      transform: scale(1.1);
    }

    .modal-body {
      padding: 2rem;
      overflow-y: auto;
      flex-grow: 1;
    }

    .resultados-modal {
      background: #f8f9fa;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1rem;
    }

    .resultados-modal pre {
      background: #fff;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .grafico-modal {
      text-align: center;
      margin-top: 1rem;
    }

    .grafico-modal img {
      max-width: 100%;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    }

    /* ====== CATEGORÍAS ====== */
    .categoria {
      margin-bottom: 3rem;
    }

    .categoria-titulo {
      font-size: 1.6rem;
      color: #0b3b67;
      margin-bottom: 1.5rem;
      padding-bottom: 0.8rem;
      border-bottom: 2px solid #e0e9f3;
      position: relative;
      font-weight: 700;
    }

    .categoria-titulo::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 80px;
      height: 3px;
      background: linear-gradient(90deg, #2575fc, #6a11cb);
      border-radius: 2px;
    }

    /* ====== FOOTER ====== */
    footer { 
      text-align: center; 
      margin-top: 3rem; 
      color: #596b75; 
      font-size: 0.95rem; 
      padding: 2rem 0;
      border-top: 1px solid #e0e9f3;
    }

    /* ====== MATRIZ INPUTS ====== */
    .matriz-inputs {
      display: none;
      margin-top: 1rem;
      padding: 1rem;
      background: #f8fbff;
      border-radius: 8px;
      border: 1px solid #d0e3ff;
    }

    .matriz-inputs.active {
      display: block;
    }

    .matriz-fila {
      display: flex;
      gap: 0.3rem;
      margin-bottom: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }

    .matriz-fila label {
      min-width: 20px;
      font-weight: 600;
      color: #08304b;
      font-size: 0.9rem;
    }

    .matriz-input {
      width: 60px;
      padding: 0.4rem;
      border: 1px solid #d0e3ff;
      border-radius: 4px;
      background: #fff;
      font-size: 0.9rem;
      text-align: center;
    }

    .matriz-ecuacion {
      font-family: 'Courier New', monospace;
      background: #f0f7ff;
      padding: 0.5rem;
      border-radius: 4px;
      margin-bottom: 0.5rem;
      border-left: 3px solid #2575fc;
      font-size: 0.9rem;
    }

    .matriz-separador {
      min-width: 20px;
      text-align: center;
      font-weight: bold;
      color: #2575fc;
    }

    /* ====== RESPONSIVE ====== */
    @media (max-width: 900px) {
      .calculo-card { 
        padding: 1.5rem;
      }
      
      .calculo-card h3 { 
        font-size: 1.2rem; 
      }
      
      .intro-card h2, .intro-card h3 { 
        font-size: 1.6rem; 
      }
      
      .modal-contenido {
        width: 95%;
        margin: 5% auto;
      }
    }

    @media (max-width: 768px) {
      .menu-toggle { 
        display: block; 
      }
      
      nav ul { 
        display: none; 
        position: absolute; 
        right: 1rem; 
        top: 4.5rem; 
        width: 250px; 
        flex-direction: column; 
        gap: 0.5rem; 
        padding: 1rem; 
        border-radius: 12px; 
        background: rgba(14, 46, 83, 0.98); 
        box-shadow: 0 10px 30px rgba(2, 14, 34, 0.3);
        backdrop-filter: blur(10px);
        z-index: 100;
      }
      
      nav ul.show { 
        display: flex; 
      }
      
      .intro-card {
        padding: 1.5rem;
      }
      
      .calculos-container {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }
      
      header h1 {
        font-size: 1.8rem;
      }
      
      header p {
        font-size: 0.9rem;
      }
      
      .modal-body {
        padding: 1rem;
      }
      
      .matriz-input {
        width: 50px;
        padding: 0.3rem;
      }
    }

    @media (max-width: 480px) {
      main {
        padding: 0 0.5rem 2rem;
      }
      
      .btn-calcular {
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
      }
      
      .modal-header {
        padding: 1rem 1.5rem;
      }
      
      .modal-header h3 {
        font-size: 1.2rem;
      }
      
      .matriz-input {
        width: 45px;
        font-size: 0.8rem;
      }
      
      .matriz-fila label {
        font-size: 0.8rem;
      }
    }

    /* Efectos de scroll suave */
    html {
      scroll-behavior: smooth;
    }

    /* Selección de texto personalizada */
    ::selection {
      background: rgba(37, 117, 252, 0.2);
      color: #08304b;
    }

    /* Scrollbar personalizado */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f1f1;
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #2575fc, #6a11cb);
      border-radius: 5px;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
</head>
<body>
  <!-- HEADER -->
  <header>
    <span class="menu-toggle" id="menu-toggle">☰</span>
    <h1>🧮 Cálculos - Métodos Numéricos</h1>
    <p>Realiza cálculos numéricos directamente desde la plataforma</p>
  </header>

  <!-- NAV -->
  <nav>
    <ul id="menu">
      <li><a href="index.html">Inicio</a></li>
      <li><a href="aprendizaje.html">Aprendizaje</a></li>
      <li><a href="calculos.html" class="activo">Cálculos</a></li>
      <li><a href="nosotros.html">Nosotros</a></li>
    </ul>
  </nav>

  <!-- MAIN -->
  <main>
    <section class="intro-card" aria-labelledby="intro-title">
      <h2 id="intro-title">Calculadora de Métodos Numéricos</h2>
      <p>Ingresa los datos requeridos para cada método y obtén resultados precisos con visualización gráfica.</p>
    </section>

    <!-- RECUADROS DE CÁLCULO PARA LOS 8 MÉTODOS PRINCIPALES -->
    <div class="categoria">
      <h2 class="categoria-titulo">Calculadoras de Métodos Numéricos</h2>
      <div class="calculos-container">
        
        <!-- Método 1: Sistemas de Ecuaciones -->
        <div class="calculo-card" data-id="m1">
          <div class="calculo-icono">
            <i class="fa-solid fa-table"></i>
          </div>
          <h3>Sistemas de Ecuaciones Algebraicas Lineales</h3>
          <form class="metodo-form" data-metodo="gauss">
            <div class="form-group">
              <label for="tipo-matriz">Tipo de Matriz:</label>
              <select id="tipo-matriz" onchange="mostrarCamposMatriz()">
                <option value="">Seleccione el tipo de matriz</option>
                <option value="2x2">2x2 (2 ecuaciones, 2 variables)</option>
                <option value="2x3">2x3 (2 ecuaciones, 3 variables)</option>
                <option value="3x3">3x3 (3 ecuaciones, 3 variables)</option>
                <option value="3x4">3x4 (3 ecuaciones, 4 variables)</option>
                <option value="4x4">4x4 (4 ecuaciones, 4 variables)</option>
                <option value="personalizada">Personalizada (matriz aumentada)</option>
              </select>
            </div>

            <!-- Matriz 2x2 -->
            <div id="matriz-2x2" class="matriz-inputs">
              <h4>Sistema 2x2</h4>
              <div class="matriz-ecuacion">Ecuación 1:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m2x2_x1" value="2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m2x2_y1" value="1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m2x2_r1" value="8">
              </div>
              <div class="matriz-ecuacion">Ecuación 2:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m2x2_x2" value="-3">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m2x2_y2" value="-1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m2x2_r2" value="-11">
              </div>
            </div>

            <!-- Matriz 2x3 -->
            <div id="matriz-2x3" class="matriz-inputs">
              <h4>Sistema 2x3</h4>
              <div class="matriz-ecuacion">Ecuación 1:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m2x3_x1" value="1">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m2x3_y1" value="2">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m2x3_z1" value="3">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m2x3_r1" value="6">
              </div>
              <div class="matriz-ecuacion">Ecuación 2:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m2x3_x2" value="2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m2x3_y2" value="-1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m2x3_z2" value="1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m2x3_r2" value="3">
              </div>
            </div>

            <!-- Matriz 3x3 -->
            <div id="matriz-3x3" class="matriz-inputs">
              <h4>Sistema 3x3</h4>
              <div class="matriz-ecuacion">Ecuación 1:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x3_x1" value="2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x3_y1" value="1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x3_z1" value="-1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x3_r1" value="8">
              </div>
              <div class="matriz-ecuacion">Ecuación 2:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x3_x2" value="-3">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x3_y2" value="-1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x3_z2" value="2">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x3_r2" value="-11">
              </div>
              <div class="matriz-ecuacion">Ecuación 3:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x3_x3" value="-2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x3_y3" value="1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x3_z3" value="2">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x3_r3" value="-3">
              </div>
            </div>

            <!-- Matriz 3x4 -->
            <div id="matriz-3x4" class="matriz-inputs">
              <h4>Sistema 3x4</h4>
              <div class="matriz-ecuacion">Ecuación 1:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x4_x1" value="1">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x4_y1" value="1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x4_z1" value="1">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m3x4_w1" value="1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x4_r1" value="10">
              </div>
              <div class="matriz-ecuacion">Ecuación 2:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x4_x2" value="2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x4_y2" value="-1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x4_z2" value="3">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m3x4_w2" value="-2">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x4_r2" value="5">
              </div>
              <div class="matriz-ecuacion">Ecuación 3:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m3x4_x3" value="3">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m3x4_y3" value="2">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m3x4_z3" value="-1">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m3x4_w3" value="1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m3x4_r3" value="8">
              </div>
            </div>

            <!-- Matriz 4x4 -->
            <div id="matriz-4x4" class="matriz-inputs">
              <h4>Sistema 4x4</h4>
              <div class="matriz-ecuacion">Ecuación 1:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m4x4_x1" value="2">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m4x4_y1" value="1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m4x4_z1" value="-1">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m4x4_w1" value="3">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m4x4_r1" value="9">
              </div>
              <div class="matriz-ecuacion">Ecuación 2:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m4x4_x2" value="-1">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m4x4_y2" value="3">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m4x4_z2" value="2">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m4x4_w2" value="1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m4x4_r2" value="8">
              </div>
              <div class="matriz-ecuacion">Ecuación 3:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m4x4_x3" value="3">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m4x4_y3" value="-1">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m4x4_z3" value="2">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m4x4_w3" value="2">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m4x4_r3" value="3">
              </div>
              <div class="matriz-ecuacion">Ecuación 4:</div>
              <div class="matriz-fila">
                <label>X:</label>
                <input type="number" class="matriz-input" id="m4x4_x4" value="1">
                <label>Y:</label>
                <input type="number" class="matriz-input" id="m4x4_y4" value="2">
                <label>Z:</label>
                <input type="number" class="matriz-input" id="m4x4_z4" value="3">
                <label>W:</label>
                <input type="number" class="matriz-input" id="m4x4_w4" value="-1">
                <div class="matriz-separador">=</div>
                <input type="number" class="matriz-input" id="m4x4_r4" value="7">
              </div>
            </div>

            <!-- Matriz Personalizada -->
            <div id="matriz-personalizada" class="matriz-inputs">
              <div class="form-group">
                <label for="matriz-aumentada">Matriz aumentada (cada fila en una línea, números separados por espacios):</label>
                <textarea id="matriz-aumentada" placeholder="2 1 -1 8
-3 -1 2 -11
-2 1 2 -3">2 1 -1 8
-3 -1 2 -11
-2 1 2 -3</textarea>
              </div>
            </div>

            <div class="form-group">
              <label for="metodo-sistema">Método de Solución:</label>
              <select id="metodo-sistema">
                <option value="gauss">Eliminación de Gauss</option>
                <option value="gauss-jordan">Gauss-Jordan</option>
                <option value="lu">Descomposición LU</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularSistemaEcuaciones()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

        <!-- Método 2: Interpolación -->
        <div class="calculo-card" data-id="m2">
          <div class="calculo-icono">
            <i class="fa-solid fa-chart-line"></i>
          </div>
          <h3>Interpolación y Ajuste de Curvas</h3>
          <form class="metodo-form" data-metodo="lagrange">
            <div class="form-group">
              <label for="puntos-x">Puntos X (separados por coma):</label>
              <input type="text" id="puntos-x" placeholder="1, 2, 3, 4" value="1, 2, 3, 4">
            </div>
            <div class="form-group">
              <label for="puntos-y">Puntos Y (separados por coma):</label>
              <input type="text" id="puntos-y" placeholder="1, 4, 9, 16" value="1, 4, 9, 16">
            </div>
            <div class="form-group">
              <label for="punto-interpolar">Punto a interpolar:</label>
              <input type="number" id="punto-interpolar" step="any" placeholder="2.5" value="2.5">
            </div>
            <div class="form-group">
              <label for="metodo-interpolacion">Método:</label>
              <select id="metodo-interpolacion">
                <option value="lagrange">Interpolación de Lagrange</option>
                <option value="newton">Diferencias Divididas de Newton</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularInterpolacion()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

        <!-- Método 3: Raíces de Ecuaciones (INCLUYE MÉTODO DE LA SECANTE) -->
        <div class="calculo-card" data-id="m3">
          <div class="calculo-icono">
            <i class="fa-solid fa-square-root-variable"></i>
          </div>
          <h3>Raíces de Ecuaciones</h3>
          <form class="metodo-form" data-metodo="biseccion">
            <div class="form-group">
              <label for="funcion-raiz">Función f(x):</label>
              <input type="text" id="funcion-raiz" placeholder="x**2 - 4" value="np.sin(x) - 0.5">
            </div>
            <div class="form-group">
              <label for="funcion-derivada-raiz">Derivada f'(x) (para Newton-Raphson):</label>
              <input type="text" id="funcion-derivada-raiz" placeholder="2*x" value="np.cos(x)">
            </div>
            <div class="form-group">
              <label for="intervalo-a">Valor inicial x₀ (para Newton) / a (para Bisección y Secante):</label>
              <input type="number" id="intervalo-a" step="any" placeholder="1.5" value="1">
            </div>
            <div class="form-group">
              <label for="intervalo-b">Valor x₁ (para Secante) / b (para Bisección):</label>
              <input type="number" id="intervalo-b" step="any" placeholder="3" value="2">
            </div>
            <div class="form-group">
              <label for="tolerancia-raiz">Tolerancia:</label>
              <input type="number" id="tolerancia-raiz" step="any" placeholder="0.001" value="0.001">
            </div>
            <div class="form-group">
              <label for="metodo-raiz">Método:</label>
              <select id="metodo-raiz">
                <option value="biseccion">Bisección</option>
                <option value="newton-rapson">Newton-Raphson</option>
                <option value="secante">Secante</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularRaices()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

        <!-- Método 4: Diferenciación Numérica (ACTUALIZADO) -->
        <div class="calculo-card" data-id="m4">
          <div class="calculo-icono">
            <i class="fa-solid fa-calculator"></i>
          </div>
          <h3>Diferenciación Numérica</h3>
          <form class="metodo-form" data-metodo="diferenciacion">
            <div class="form-group">
              <label for="funcion-derivada">Función f(x):</label>
              <input type="text" id="funcion-derivada" placeholder="np.sin(x)" value="np.sin(x)">
            </div>
            <div class="form-group">
              <label for="intervalo-a-derivada">Valor inicial del intervalo (a):</label>
              <input type="number" id="intervalo-a-derivada" step="any" placeholder="0" value="0">
            </div>
            <div class="form-group">
              <label for="intervalo-b-derivada">Valor final del intervalo (b):</label>
              <input type="number" id="intervalo-b-derivada" step="any" placeholder="6.28" value="6.28">
            </div>
            <div class="form-group">
              <label for="n-puntos-derivada">Número de puntos:</label>
              <input type="number" id="n-puntos-derivada" placeholder="100" value="100">
            </div>
            <div class="form-group">
              <label for="metodo-derivada">Método:</label>
              <select id="metodo-derivada">
                <option value="adelante">Diferencia hacia adelante</option>
                <option value="atras">Diferencia hacia atrás</option>
                <option value="centrada">Diferencia centrada</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularDerivada()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

        <!-- Método 5: Integración Numérica (ACTUALIZADO CON REGLA DEL TRAPECIO) -->
        <div class="calculo-card" data-id="m5">
          <div class="calculo-icono">
            <i class="fa-solid fa-integral"></i>
          </div>
          <h3>Integración Numérica</h3>
          <form class="metodo-form" data-metodo="integracion">
            <div class="form-group">
              <label for="funcion-integral">Función f(x):</label>
              <input type="text" id="funcion-integral" placeholder="np.sin(x)" value="np.sin(x)">
            </div>
            <div class="form-group">
              <label for="limite-a">Límite inferior a:</label>
              <input type="number" id="limite-a" step="any" placeholder="0" value="0">
            </div>
            <div class="form-group">
              <label for="limite-b">Límite superior b:</label>
              <input type="number" id="limite-b" step="any" placeholder="3.14" value="3.14">
            </div>
            <div class="form-group">
              <label for="n-integral">Número de subintervalos n:</label>
              <input type="number" id="n-integral" placeholder="10" value="10">
            </div>
            <div class="form-group">
              <label for="metodo-integral">Método:</label>
              <select id="metodo-integral">
                <option value="trapecio">Regla del Trapecio</option>
                <option value="simpson13">Regla de Simpson 1/3</option>
                <option value="simpson38">Regla de Simpson 3/8</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularIntegral()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

        <!-- Método 6: Problemas de Valor Inicial -->
        <div class="calculo-card" data-id="m6">
          <div class="calculo-icono">
            <i class="fa-solid fa-play"></i>
          </div>
          <h3>Problemas de Valor Inicial</h3>
          <form class="metodo-form" data-metodo="pvi">
            <div class="form-group">
              <label for="funcion-edo">EDO: dy/dx = f(x, y):</label>
              <input type="text" id="funcion-edo" placeholder="x + y" value="x + y">
            </div>
            <div class="form-group">
              <label for="condicion-inicial">Condición inicial y(x₀):</label>
              <input type="number" id="condicion-inicial" step="any" placeholder="1" value="1">
            </div>
            <div class="form-group">
              <label for="x-inicial">x₀:</label>
              <input type="number" id="x-inicial" step="any" placeholder="0" value="0">
            </div>
            <div class="form-group">
              <label for="x-final">x final:</label>
              <input type="number" id="x-final" step="any" placeholder="2" value="2">
            </div>
            <div class="form-group">
              <label for="paso-edo">Paso h:</label>
              <input type="number" id="paso-edo" step="any" placeholder="0.1" value="0.1">
            </div>
            <div class="form-group">
              <label for="metodo-edo">Método:</label>
              <select id="metodo-edo">
                <option value="euler">Método de Euler</option>
                <option value="runge-kutta">Runge-Kutta 4º orden</option>
              </select>
            </div>
            <button type="button" class="btn-calcular" onclick="calcularEDO()">
              <i class="fa-solid fa-calculator"></i> Calcular
            </button>
          </form>
        </div>

      </div>
    </div>

    <!-- Sección para ejecutar código Python -->
    <div class="categoria">
      <h2 class="categoria-titulo">Ejecutar Código Python</h2>
      <div class="calculo-card">
        <div class="calculo-icono">
          <i class="fa-brands fa-python"></i>
        </div>
        <h3>Consola Python para Gráficas y Cálculos Avanzados</h3>
        <form>
          <div class="form-group">
            <label for="codigo-python">Código Python:</label>
            <textarea id="codigo-python" placeholder="# Escribe tu código Python aquí
import matplotlib.pyplot as plt
import numpy as np

# Ejemplo: Gráfica de una función
x = np.linspace(-5, 5, 100)
y = x**2

plt.figure(figsize=(8, 6))
plt.plot(x, y, 'b-', linewidth=2)
plt.title('Gráfica de y = x²')
plt.grid(True)
plt.show()" rows="10">import matplotlib.pyplot as plt
import numpy as np

# Definir la función f(x) que queremos resolver
def f(x):
    return np.sin(x) - 0.5  # La función f(x) = sin(x) - 0.5

# Método de la secante
def secante(f, x0, x1, tol=1e-6, max_iter=100):
    iteraciones = 0
    while abs(x1 - x0) > tol and iteraciones < max_iter:
        # Aplicamos la fórmula de la secante
        x2 = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))
        # Actualizamos los puntos
        x0, x1 = x1, x2
        iteraciones += 1
    return x1

# Solicitar al usuario los puntos iniciales
x0 = float(input("Introduce el primer valor inicial (x0): "))
x1 = float(input("Introduce el segundo valor inicial (x1): "))

# Encontramos la raíz usando el método de la secante
raiz = secante(f, x0, x1)

# Mostrar el resultado
print(f"\nLa raíz aproximada es: {raiz}")

# Graficar la función para ver cómo se comporta
x = np.linspace(0, 2*np.pi, 400)
y = f(x)

plt.plot(x, y, label="f(x) = sin(x) - 0.5")
plt.axhline(0, color='black',linewidth=1)  # Línea horizontal en y=0
plt.axvline(raiz, color='r', linestyle='--', label=f"Raíz aproximada: {raiz:.5f}")
plt.title('Método de la Secante para encontrar la raíz de f(x) = sin(x) - 0.5')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend()
plt.grid(True)
plt.show()</textarea>
          </div>
          <button type="button" class="btn-calcular" onclick="ejecutarPython()">
            <i class="fa-brands fa-python"></i> Ejecutar Python
          </button>
        </form>
      </div>
    </div>

  </main>

  <!-- FOOTER -->
  <footer>
    <p>© 2025 Métodos Numéricos - Universidad Mariana</p>
  </footer>

  <!-- Ventanas modales para resultados -->
  <div id="modal-resultados" class="modal">
    <div class="modal-contenido">
      <div class="modal-header">
        <h3 id="modal-titulo">Resultados del Cálculo</h3>
        <button class="cerrar">&times;</button>
      </div>
      <div class="modal-body">
        <div id="modal-contenido"></div>
      </div>
    </div>
  </div>

  <!-- Pyodide -->
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <script>
    // Toggle del menú móvil
    document.getElementById('menu-toggle').addEventListener('click', function() {
      const menu = document.getElementById('menu');
      menu.classList.toggle('show');
    });

    // Cerrar menú al hacer clic en un enlace
    document.querySelectorAll('nav a').forEach(link => {
      link.addEventListener('click', function() {
        const menu = document.getElementById('menu');
        menu.classList.remove('show');
      });
    });

    // Inicialización de Pyodide
    let pyodide;
    async function initPyodide() {
      pyodide = await loadPyodide({
        indexURL: "https://cdn.jsdelivr.net/pyodide/v0.24.1/full/"
      });
      await pyodide.loadPackage(["numpy", "matplotlib"]);
      console.log("Pyodide cargado correctamente");
    }
    initPyodide();

    // Funciones para manejar ventanas modales
    const modal = document.getElementById('modal-resultados');
    const modalTitulo = document.getElementById('modal-titulo');
    const modalContenido = document.getElementById('modal-contenido');
    const cerrarBtn = document.querySelector('.cerrar');

    function mostrarModal(titulo, contenido) {
      modalTitulo.textContent = titulo;
      modalContenido.innerHTML = contenido;
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden';
    }

    function cerrarModal() {
      modal.style.display = 'none';
      document.body.style.overflow = 'auto';
    }

    cerrarBtn.onclick = cerrarModal;
    window.onclick = function(event) {
      if (event.target == modal) {
        cerrarModal();
      }
    }

    // Función para mostrar resultados en modal
    function mostrarResultados(titulo, texto, grafico = null) {
      let contenido = `
        <div class="resultados-modal">
          <pre>${texto}</pre>
        </div>
      `;
      
      if (grafico) {
        contenido += `
          <div class="grafico-modal">
            <h4>Visualización Gráfica</h4>
            <img src="${grafico}" alt="Gráfico del resultado">
          </div>
        `;
      }
      
      mostrarModal(titulo, contenido);
    }

    // Función para mostrar campos de matriz según el tipo seleccionado
    function mostrarCamposMatriz() {
      const tipoMatriz = document.getElementById('tipo-matriz').value;
      
      // Ocultar todos los campos de matriz
      document.querySelectorAll('.matriz-inputs').forEach(div => {
        div.classList.remove('active');
      });
      
      // Mostrar solo el campo seleccionado
      if (tipoMatriz) {
        document.getElementById(`matriz-${tipoMatriz}`).classList.add('active');
      }
    }

    // Función para obtener la matriz aumentada según el tipo seleccionado
    function obtenerMatrizDesdeFormulario() {
      const tipoMatriz = document.getElementById('tipo-matriz').value;
      
      if (tipoMatriz === 'personalizada') {
        return document.getElementById('matriz-aumentada').value;
      }
      
      let matriz = '';
      
      switch(tipoMatriz) {
        case '2x2':
          matriz = 
            document.getElementById('m2x2_x1').value + ' ' +
            document.getElementById('m2x2_y1').value + ' ' +
            document.getElementById('m2x2_r1').value + '\n' +
            document.getElementById('m2x2_x2').value + ' ' +
            document.getElementById('m2x2_y2').value + ' ' +
            document.getElementById('m2x2_r2').value;
          break;
          
        case '2x3':
          matriz = 
            document.getElementById('m2x3_x1').value + ' ' +
            document.getElementById('m2x3_y1').value + ' ' +
            document.getElementById('m2x3_z1').value + ' ' +
            document.getElementById('m2x3_r1').value + '\n' +
            document.getElementById('m2x3_x2').value + ' ' +
            document.getElementById('m2x3_y2').value + ' ' +
            document.getElementById('m2x3_z2').value + ' ' +
            document.getElementById('m2x3_r2').value;
          break;
          
        case '3x3':
          matriz = 
            document.getElementById('m3x3_x1').value + ' ' +
            document.getElementById('m3x3_y1').value + ' ' +
            document.getElementById('m3x3_z1').value + ' ' +
            document.getElementById('m3x3_r1').value + '\n' +
            document.getElementById('m3x3_x2').value + ' ' +
            document.getElementById('m3x3_y2').value + ' ' +
            document.getElementById('m3x3_z2').value + ' ' +
            document.getElementById('m3x3_r2').value + '\n' +
            document.getElementById('m3x3_x3').value + ' ' +
            document.getElementById('m3x3_y3').value + ' ' +
            document.getElementById('m3x3_z3').value + ' ' +
            document.getElementById('m3x3_r3').value;
          break;
          
        case '3x4':
          matriz = 
            document.getElementById('m3x4_x1').value + ' ' +
            document.getElementById('m3x4_y1').value + ' ' +
            document.getElementById('m3x4_z1').value + ' ' +
            document.getElementById('m3x4_w1').value + ' ' +
            document.getElementById('m3x4_r1').value + '\n' +
            document.getElementById('m3x4_x2').value + ' ' +
            document.getElementById('m3x4_y2').value + ' ' +
            document.getElementById('m3x4_z2').value + ' ' +
            document.getElementById('m3x4_w2').value + ' ' +
            document.getElementById('m3x4_r2').value + '\n' +
            document.getElementById('m3x4_x3').value + ' ' +
            document.getElementById('m3x4_y3').value + ' ' +
            document.getElementById('m3x4_z3').value + ' ' +
            document.getElementById('m3x4_w3').value + ' ' +
            document.getElementById('m3x4_r3').value;
          break;
          
        case '4x4':
          matriz = 
            document.getElementById('m4x4_x1').value + ' ' +
            document.getElementById('m4x4_y1').value + ' ' +
            document.getElementById('m4x4_z1').value + ' ' +
            document.getElementById('m4x4_w1').value + ' ' +
            document.getElementById('m4x4_r1').value + '\n' +
            document.getElementById('m4x4_x2').value + ' ' +
            document.getElementById('m4x4_y2').value + ' ' +
            document.getElementById('m4x4_z2').value + ' ' +
            document.getElementById('m4x4_w2').value + ' ' +
            document.getElementById('m4x4_r2').value + '\n' +
            document.getElementById('m4x4_x3').value + ' ' +
            document.getElementById('m4x4_y3').value + ' ' +
            document.getElementById('m4x4_z3').value + ' ' +
            document.getElementById('m4x4_w3').value + ' ' +
            document.getElementById('m4x4_r3').value + '\n' +
            document.getElementById('m4x4_x4').value + ' ' +
            document.getElementById('m4x4_y4').value + ' ' +
            document.getElementById('m4x4_z4').value + ' ' +
            document.getElementById('m4x4_w4').value + ' ' +
            document.getElementById('m4x4_r4').value;
          break;
      }
      
      return matriz;
    }

    // Función para calcular sistemas de ecuaciones
    async function calcularSistemaEcuaciones() {
      if (!pyodide) {
        alert("Pyodide aún se está cargando. Por favor, espera unos segundos.");
        return;
      }

      const tipoMatriz = document.getElementById('tipo-matriz').value;
      if (!tipoMatriz) {
        alert("Por favor, selecciona un tipo de matriz.");
        return;
      }

      const matrizTexto = obtenerMatrizDesdeFormulario();
      const metodo = document.getElementById('metodo-sistema').value;
      
      mostrarModal("Calculando...", "<p>Procesando la matriz y aplicando el método seleccionado...</p>");

      try {
        let code;
        let titulo = "";
        
        if (metodo === 'gauss') {
          titulo = "Resultados - Eliminación de Gauss";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Leer matriz aumentada
A = [list(map(float, row.split())) for row in """${matrizTexto}""".splitlines()]
A = np.array(A, dtype=float)

n, m = A.shape
pasos = []

mostrar = lambda M, msg: pasos.append(msg + "\\n" + str(M) + "\\n")
mostrar(A, "Matriz inicial:")

# Eliminación hacia adelante
for i in range(n):
    if A[i,i] == 0:
        for k in range(i+1, n):
            if A[k,i] != 0:
                A[[i,k]] = A[[k,i]]
                pasos.append(f"Se cambia fila {i+1} con fila {k+1}")
                break
    pivote = A[i,i]
    if pivote == 0:
        continue
    A[i] = A[i] / pivote
    mostrar(A, f"Dividimos fila {i+1} entre {pivote} para hacer pivote = 1")
    for j in range(i+1, n):
        factor = A[j,i]
        A[j] = A[j] - factor*A[i]
        mostrar(A, f"Eliminamos el valor en fila {j+1}, columna {i+1}")

# Sustitución regresiva
x = np.zeros(n)
for i in range(n-1, -1, -1):
    x[i] = A[i,-1] - np.dot(A[i,i+1:n], x[i+1:n])
pasos.append("Solución final: " + str(x))

# Graficar si es 2x2 o 3x3
img = ""
if n == 2:
    x_vals = np.linspace(-10,10,400)
    plt.figure()
    for i in range(2):
        a,b,c = A[i,0], A[i,1], A[i,2]
        if b != 0:
            y = (c - a*x_vals)/b
            plt.plot(x_vals,y,label=f"Ecuación {i+1}")
    plt.legend(); plt.grid();
    plt.title("Sistema 2x2")
    buf = BytesIO(); plt.savefig(buf, format='png'); buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()
elif n == 3:
    from mpl_toolkits.mplot3d import Axes3D
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    x_vals = np.linspace(-10,10,20)
    y_vals = np.linspace(-10,10,20)
    X, Y = np.meshgrid(x_vals, y_vals)
    for i in range(3):
        a,b,c,d = A[i,0], A[i,1], A[i,2], A[i,3]
        if c != 0:
            Z = (d - a*X - b*Y)/c
            ax.plot_surface(X,Y,Z,alpha=0.3)
    ax.set_title("Sistema 3x3");
    buf = BytesIO(); plt.savefig(buf, format='png'); buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()

"\\n".join(pasos), img
          `;
        } else if (metodo === 'gauss-jordan') {
          titulo = "Resultados - Gauss-Jordan";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Leer matriz
A = [list(map(float, row.split())) for row in """${matrizTexto}""".splitlines()]
A = np.array(A, dtype=float)

n, m = A.shape
pasos = []

# Mostrar matriz con explicación
mostrar = lambda M, msg: pasos.append(msg + "\\n" + str(M) + "\\n")
mostrar(A, "Matriz inicial:")

# Gauss-Jordan
for i in range(n):
    if A[i,i] == 0:
        for k in range(i+1, n):
            if A[k,i] != 0:
                A[[i,k]] = A[[k,i]]
                pasos.append(f"Se cambia fila {i+1} con fila {k+1}")
                break
    pivote = A[i,i]
    A[i] = A[i] / pivote
    mostrar(A, f"Dividimos fila {i+1} por {pivote} para hacer pivote = 1")
    for j in range(n):
        if j != i:
            factor = A[j,i]
            A[j] = A[j] - factor*A[i]
            mostrar(A, f"Quitamos {factor}*fila {i+1} de fila {j+1}")

sol = A[:,-1]
pasos.append("Solución directa: " + str(sol))

# Graficar si es 2x2 o 3x3
img = ""
if n == 2:
    x = np.linspace(-10,10,400)
    plt.figure()
    for i in range(2):
        a,b,c = A[i,0], A[i,1], A[i,2]
        if b != 0:
            y = (c - a*x)/b
            plt.plot(x,y,label=f"Ecuación {i+1}")
    plt.legend(); plt.grid();
    plt.title("Sistema 2x2")
    buf = BytesIO(); plt.savefig(buf, format='png'); buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()
elif n == 3:
    from mpl_toolkits.mplot3d import Axes3D
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    x = np.linspace(-10,10,20)
    y = np.linspace(-10,10,20)
    X, Y = np.meshgrid(x, y)
    for i in range(3):
        a,b,c,d = A[i,0], A[i,1], A[i,2], A[i,3]
        if c != 0:
            Z = (d - a*X - b*Y)/c
            ax.plot_surface(X,Y,Z,alpha=0.3)
    ax.set_title("Sistema 3x3");
    buf = BytesIO(); plt.savefig(buf, format='png'); buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()

"\\n".join(pasos), img
          `;
        } else if (metodo === 'lu') {
          titulo = "Resultados - Descomposición LU";
          code = `
import numpy as np

def parse_matrix(s):
    rows = [r for r in s.splitlines() if r.strip()]
    M = [list(map(float, r.split())) for r in rows]
    return np.array(M, dtype=float)

A = parse_matrix("""${matrizTexto}""")
n, m = A.shape
if n != m-1:
    raise Exception('La matriz debe ser n x (n+1) para ser una matriz aumentada')

# Extraer la matriz de coeficientes y el vector b
b = A[:,-1]
A = A[:,:-1]

# Preparar salida de texto
lines = []
lines.append('Paso 0: Esta es la matriz A que diste:')
for row in A:
    lines.append('  ' + '  '.join(f"{x:8.4f}" for x in row))
lines.append('\\nVector b:')
for val in b:
    lines.append('  ' + f"{val:8.4f}")

# Implementar Doolittle con pivot parcial (PLU). Guardamos P si hay intercambios.
P = np.eye(n)
L = np.zeros((n,n))
U = A.copy()
permutations = []

for k in range(n):
    # Pivot parcial: buscar fila con mayor |U[i,k]| para i>=k
    pivot_row = max(range(k, n), key=lambda i: abs(U[i,k]))
    if abs(U[pivot_row,k]) < 1e-12:
        lines.append(f'Atención: pivote prácticamente cero en columna {k+1}. La descomposición LU puede fallar.')
        continue
    if pivot_row != k:
        # intercambiar filas en U y en P y en L (parcial)
        U[[k,pivot_row],:] = U[[pivot_row,k],:]
        P[[k,pivot_row],:] = P[[pivot_row,k],:]
        if k>0:
            L[[k,pivot_row],:k] = L[[pivot_row,k],:k]
        permutations.append((k+1, pivot_row+1))
        lines.append(f'Swap: intercambiamos fila {k+1} con fila {pivot_row+1} para pivotar.')
    # Construir L y actualizar U
    L[k,k] = 1.0
    pivot = U[k,k]
    for i in range(k+1, n):
        multiplier = U[i,k] / pivot
        L[i,k] = multiplier
        U[i,:] = U[i,:] - multiplier * U[k,:]
    # Mostrar L y U después del paso
    lines.append(f'Después del paso k={k+1}:')
    lines.append('L parcial:')
    for r in L:
        lines.append('  ' + '  '.join(f"{x:8.4f}" for x in r))
    lines.append('U parcial:')
    for r in U:
        lines.append('  ' + '  '.join(f"{x:8.4f}" for x in r))

# Resultado final
lines.append('\\nResultado final:')
lines.append('Matriz P (permutación):')
for r in P:
    lines.append('  ' + '  '.join(f"{int(x):1d}" if abs(x-round(x))<1e-9 else f"{x:8.4f}" for x in r))
lines.append('Matriz L:')
for r in L:
    lines.append('  ' + '  '.join(f"{x:8.4f}" for x in r))
lines.append('Matriz U:')
for r in U:
    lines.append('  ' + '  '.join(f"{x:8.4f}" for x in r))

# Resolver A x = b usando PLU: PA = LU -> Ly = Pb -> Ux = y
Pb = P.dot(b)
lines.append('\\nResolver sistema usando PLU: Pb es:')
for val in Pb:
    lines.append('  ' + f"{val:8.4f}")
# forward substitution Ly = Pb
y = np.zeros(n)
for i in range(n):
    y[i] = Pb[i] - np.dot(L[i,:i], y[:i])
lines.append('\\nSolución intermedia y (Ly = Pb):')
for val in y:
    lines.append('  ' + f"{val:8.4f}")
# back substitution Ux = y
x = np.zeros(n)
for i in range(n-1, -1, -1):
    x[i] = (y[i] - np.dot(U[i,i+1:], x[i+1:])) / U[i,i]
lines.append('\\nSolución final x:')
for i,val in enumerate(x):
    lines.append(f'  x{i+1} = {val:12.6f}')

"\\n".join(lines), ""
          `;
        }

        const [texto, img] = await pyodide.runPythonAsync(code);
        mostrarResultados(titulo, texto, img);
      } catch (err) {
        mostrarResultados("Error", 'Error: ' + err);
      }
    }

    // Función para calcular interpolación
    async function calcularInterpolacion() {
      if (!pyodide) {
        alert("Pyodide aún se está cargando. Por favor, espera unos segundos.");
        return;
      }

      const puntosX = document.getElementById('puntos-x').value;
      const puntosY = document.getElementById('puntos-y').value;
      const puntoInterpolar = document.getElementById('punto-interpolar').value;
      const metodo = document.getElementById('metodo-interpolacion').value;
      
      mostrarModal("Calculando...", "<p>Procesando los puntos y aplicando interpolación...</p>");

      try {
        let code;
        let titulo = "";
        
        if (metodo === 'lagrange') {
          titulo = "Resultados - Interpolación de Lagrange";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Convertir puntos de entrada
x_puntos = [float(x.strip()) for x in """${puntosX}""".split(",")]
y_puntos = [float(y.strip()) for y in """${puntosY}""".split(",")]
x_eval = float("""${puntoInterpolar}""")

n = len(x_puntos)
pasos = []

# Verificar que no hay x duplicados
if len(set(x_puntos)) != n:
    raise Exception("ERROR: No se puede interpolar con valores de x repetidos.")

pasos.append("=== INTERPOLACIÓN DE LAGRANGE PASO A PASO ===")
pasos.append(f"Puntos dados: {list(zip(x_puntos, y_puntos))}")
pasos.append(f"Punto a interpolar: x = {x_eval}")
pasos.append("")

# Algoritmo de Lagrange
resultado = 0.0

for i in range(n):
    xi = x_puntos[i]
    yi = y_puntos[i]
    Li = 1.0
    
    pasos.append(f"Punto {i}: (x_{i}={xi}, y_{i}={yi})")
    
    for j in range(n):
        if j == i:
            continue
        numerador = (x_eval - x_puntos[j])
        denominador = (xi - x_puntos[j])
        factor = numerador / denominador
        Li *= factor
        
        pasos.append(f"  j={j}: (x - x_{j})=({x_eval}-{x_puntos[j]})={numerador}")
        pasos.append(f"        (x_{i} - x_{j})=({xi}-{x_puntos[j]})={denominador}")
        pasos.append(f"  Factor = {numerador}/{denominador} = {factor}")
        pasos.append(f"  L_{i} acumulado = {Li}")
    
    contribucion = yi * Li
    resultado += contribucion
    pasos.append(f"L_{i}({x_eval}) = {Li}")
    pasos.append(f"Contribución: y_{i}*L_{i} = {yi}*{Li} = {contribucion}")
    pasos.append(f"Suma parcial = {resultado}")
    pasos.append("")

pasos.append("=== RESULTADO FINAL ===")
pasos.append(f"P({x_eval}) = {resultado}")

# Generar gráfica
img = ""
try:
    x_min = min(x_puntos)
    x_max = max(x_puntos)
    margen = (x_max - x_min) * 0.2 if x_max != x_min else 1.0
    x_vals = np.linspace(x_min - margen, x_max + margen, 300)
    
    # Función para evaluar Lagrange sin mostrar pasos
    def lagrange_eval(x_puntos, y_puntos, x):
        n = len(x_puntos)
        resultado = 0.0
        for i in range(n):
            Li = 1.0
            for j in range(n):
                if j != i:
                    Li *= (x - x_puntos[j]) / (x_puntos[i] - x_puntos[j])
            resultado += y_puntos[i] * Li
        return resultado
    
    y_vals = [lagrange_eval(x_puntos, y_puntos, xv) for xv in x_vals]
    
    plt.figure(figsize=(10, 6))
    plt.plot(x_vals, y_vals, label="Polinomio de Lagrange", color="blue", linewidth=2)
    plt.scatter(x_puntos, y_puntos, color="red", s=100, label="Puntos dados", zorder=5)
    plt.scatter([x_eval], [resultado], color="green", s=100, label=f"P({x_eval}) = {resultado:.4f}", zorder=5)
    
    for i, (xi, yi) in enumerate(zip(x_puntos, y_puntos)):
        plt.annotate(f"({xi},{yi})", (xi, yi), textcoords="offset points", xytext=(5,5), fontsize=9)
    
    plt.title("Interpolación de Lagrange")
    plt.xlabel("x")
    plt.ylabel("P(x)")
    plt.grid(True, alpha=0.3)
    plt.legend()
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()
except Exception as e:
    pasos.append(f"Nota: No se pudo generar la gráfica: {e}")

"\\n".join(pasos), img
          `;
        } else if (metodo === 'newton') {
          titulo = "Resultados - Diferencias Divididas de Newton";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Convertir puntos de entrada
x_puntos = [float(x.strip()) for x in """${puntosX}""".split(",")]
y_puntos = [float(y.strip()) for y in """${puntosY}""".split(",")]
x_eval = float("""${puntoInterpolar}""")

n = len(x_puntos)
pasos = []

# Verificar que no hay x duplicados
if len(set(x_puntos)) != n:
    raise Exception("ERROR: No se puede interpolar con valores de x repetidos.")

pasos.append("=== DIFERENCIAS DIVIDIDAS DE NEWTON PASO A PASO ===")
pasos.append(f"Puntos dados: {list(zip(x_puntos, y_puntos))}")
pasos.append(f"Punto a interpolar: x = {x_eval}")
pasos.append("")

# Construir tabla de diferencias divididas CORREGIDA
tabla = np.zeros((n, n))
for i in range(n):
    tabla[i, 0] = y_puntos[i]

pasos.append("Construyendo la tabla de diferencias divididas:")
pasos.append("Primera columna (diferencias de orden 0):")
for i in range(n):
    pasos.append(f"  f[x_{i}] = {y_puntos[i]}")

# Calcular diferencias divididas
for j in range(1, n):
    pasos.append(f"")
    pasos.append(f"--- Diferencias de orden {j} ---")
    for i in range(n - j):
        numerador = tabla[i+1, j-1] - tabla[i, j-1]
        denominador = x_puntos[i+j] - x_puntos[i]
        tabla[i, j] = numerador / denominador
        pasos.append(f"f[x_{i},...,x_{i+j}] = (f[x_{i+1},...,x_{i+j-1}] - f[x_{i},...,x_{i+j-1}]) / (x_{i+j} - x_{i})")
        pasos.append(f"  = ({tabla[i+1, j-1]:.6f} - {tabla[i, j-1]:.6f}) / ({x_puntos[i+j]} - {x_puntos[i]})")
        pasos.append(f"  = {numerador:.6f} / {denominador:.6f} = {tabla[i, j]:.6f}")

# Mostrar tabla completa
pasos.append(f"")
pasos.append("=== TABLA COMPLETA DE DIFERENCIAS DIVIDIDAS ===")
for i in range(n):
    fila = f"x_{i} = {x_puntos[i]:.2f}: "
    for j in range(n-i):
        fila += f"{tabla[i, j]:.6f}  "
    pasos.append(fila)

# Aplicar el polinomio de Newton CORREGIDO
pasos.append(f"")
pasos.append("=== APLICANDO POLINOMIO DE NEWTON ===")
resultado = tabla[0, 0]
pasos.append(f"P({x_eval}) = {resultado:.6f}")

producto = 1.0
for i in range(1, n):
    producto *= (x_eval - x_puntos[i-1])
    termino = tabla[0, i] * producto
    resultado += termino
    
    # Construir la expresión del término
    expresion = f" + {tabla[0, i]:.6f}"
    for k in range(i):
        expresion += f"*(x - {x_puntos[k]:.2f})"
    
    pasos.append(f"{expresion}")
    pasos.append(f"  = {tabla[0, i]:.6f} * {producto:.6f} = {termino:.6f}")
    pasos.append(f"Suma parcial = {resultado:.6f}")

pasos.append(f"")
pasos.append("=== RESULTADO FINAL ===")
pasos.append(f"P({x_eval}) = {resultado:.10f}")

# Generar gráfica CORREGIDA
img = ""
try:
    x_min = min(x_puntos)
    x_max = max(x_puntos)
    margen = (x_max - x_min) * 0.2 if x_max != x_min else 1.0
    x_vals = np.linspace(x_min - margen, x_max + margen, 300)
    
    # Función para evaluar Newton CORREGIDA
    def newton_eval(x_puntos, tabla, x):
        n = len(x_puntos)
        resultado = tabla[0, 0]
        producto = 1.0
        for i in range(1, n):
            producto *= (x - x_puntos[i-1])
            resultado += tabla[0, i] * producto
        return resultado
    
    y_vals = [newton_eval(x_puntos, tabla, xv) for xv in x_vals]
    
    plt.figure(figsize=(10, 6))
    plt.plot(x_vals, y_vals, label="Polinomio de Newton", color="purple", linewidth=2)
    plt.scatter(x_puntos, y_puntos, color="red", s=100, label="Puntos dados", zorder=5)
    plt.scatter([x_eval], [resultado], color="green", s=100, label=f"P({x_eval}) = {resultado:.4f}", zorder=5)
    
    for i, (xi, yi) in enumerate(zip(x_puntos, y_puntos)):
        plt.annotate(f"({xi},{yi})", (xi, yi), textcoords="offset points", xytext=(5,5), fontsize=9)
    
    plt.title("Interpolación de Newton - Diferencias Divididas")
    plt.xlabel("x")
    plt.ylabel("P(x)")
    plt.grid(True, alpha=0.3)
    plt.legend()
    
    buf = BytesIO()
    plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
    buf.seek(0)
    img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
    plt.close()
except Exception as e:
    pasos.append(f"Nota: No se pudo generar la gráfica: {e}")

"\\n".join(pasos), img
          `;
        }

        const [texto, img] = await pyodide.runPythonAsync(code);
        mostrarResultados(titulo, texto, img);
      } catch (err) {
        mostrarResultados("Error", 'Error: ' + err);
      }
    }

    // Función para calcular raíces de ecuaciones (INCLUYE MÉTODO DE LA SECANTE)
    async function calcularRaices() {
      if (!pyodide) {
        alert("Pyodide aún se está cargando. Por favor, espera unos segundos.");
        return;
      }

      const funcion = document.getElementById('funcion-raiz').value;
      const derivada = document.getElementById('funcion-derivada-raiz').value;
      const a = document.getElementById('intervalo-a').value;
      const b = document.getElementById('intervalo-b').value;
      const tolerancia = document.getElementById('tolerancia-raiz').value;
      const metodo = document.getElementById('metodo-raiz').value;
      
      mostrarModal("Calculando...", "<p>Procesando la función y aplicando el método seleccionado...</p>");

      try {
        let code;
        let titulo = "";
        
        if (metodo === 'biseccion') {
          titulo = "Resultados - Método de Bisección";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Función de entrada
f_str = """${funcion}"""
f = lambda x: eval(f_str, {"x": x, "np": np})

a = float("""${a}""")
b = float("""${b}""")
tol = float("""${tolerancia}""")
max_iter = 50

pasos = []

pasos.append("🌟 Bienvenido al método de BISECCIÓN 🌟")
pasos.append("Voy a buscar dónde la función se hace CERO (la raíz).")
pasos.append(f"Empezamos con el intervalo: a = {a}, b = {b}")
pasos.append("--------------------------------------------------")

# Verificar condición inicial
if f(a) * f(b) > 0:
    pasos.append("⚠️ Error: La función tiene el mismo signo en a y b.")
    pasos.append("Necesito que f(a) y f(b) tengan signos opuestos.")
    raiz = None
    historia = []
else:
    historia = []
    raiz = None

    for i in range(1, max_iter + 1):
        m = (a + b) / 2  # punto medio
        fm = f(m)

        pasos.append(f"🔹 Iteración {i}:")
        pasos.append(f"   a = {a:.6f}, b = {b:.6f}")
        pasos.append(f"   El punto medio es m = {m:.6f}")
        pasos.append(f"   f(m) = {fm:.6f}")

        historia.append((a, b, m, fm))

        # Criterio de parada
        if abs(fm) < tol or (b - a)/2 < tol:
            pasos.append("✅ ¡Encontré la raíz aproximada!")
            raiz = m
            break

        # Revisamos en qué sub-intervalo está la raíz
        if f(a) * fm < 0:
            b = m
            pasos.append("👉 La raíz está entre a y m. Ahora b = m")
        else:
            a = m
            pasos.append("👉 La raíz está entre m y b. Ahora a = m")

        pasos.append("--------------------------------------------------")

    if raiz is not None:
        pasos.append(f"\\n🌈 La raíz aproximada es: x = {raiz:.6f}")
        pasos.append(f"f({raiz:.6f}) = {f(raiz):.6f}")
    else:
        pasos.append("❌ No se pudo encontrar la raíz en el número máximo de iteraciones")

# Generar gráfica
img = ""
try:
    if raiz is not None:
        # Crear un rango de valores para x
        x_min = min(historia[0][0], historia[0][1], raiz) - 1
        x_max = max(historia[0][0], historia[0][1], raiz) + 1
        x_vals = np.linspace(x_min, x_max, 400)
        y_vals = [f(x) for x in x_vals]
        
        plt.figure(figsize=(10, 6))
        
        # Graficar la función
        plt.plot(x_vals, y_vals, label=f"f(x) = {f_str}", color="blue", linewidth=2)
        plt.axhline(0, color="black", linewidth=0.8)  # eje X
        
        # Graficar los intervalos y puntos medios
        for i, (ai, bi, mi, fmi) in enumerate(historia):
            plt.plot([ai, bi], [0, 0], 'ro-', alpha=0.3, markersize=5)
            plt.plot(mi, fmi, 'ro', markersize=6)
            plt.text(mi, fmi, f"{i+1}", fontsize=8, color="red")
        
        # Marcar la raíz final
        plt.plot(raiz, f(raiz), 'go', markersize=8, label=f"Raíz: x ≈ {raiz:.4f}")
        
        plt.title("Método de Bisección - Paso a paso")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True, alpha=0.3)
        plt.legend()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
        plt.close()
except Exception as e:
    pasos.append(f"Nota: No se pudo generar la gráfica: {e}")

"\\n".join(pasos), img
          `;
        } else if (metodo === 'newton-rapson') {
          titulo = "Resultados - Método de Newton-Raphson";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Función de entrada
f_str = """${funcion}"""
df_str = """${derivada}"""

f = lambda x: eval(f_str, {"x": x, "np": np})
df = lambda x: eval(df_str, {"x": x, "np": np})

x0 = float("""${a}""")
tol = float("""${tolerancia}""")
max_iter = 50

pasos = []

pasos.append("🌟 Bienvenido al método de NEWTON-RAPHSON 🌟")
pasos.append("Voy a buscar dónde la función se hace CERO (la raíz).")
pasos.append(f"Empezamos con el valor inicial: x0 = {x0}")
pasos.append("--------------------------------------------------")

historia = []
x = x0

for i in range(1, max_iter + 1):
    fx = f(x)
    dfx = df(x)

    if dfx == 0:
        pasos.append("⚠️ La derivada se volvió cero. No puedo continuar.")
        raiz = None
        break

    x_new = x - fx / dfx

    pasos.append(f"🔹 Iteración {i}:")
    pasos.append(f"   x = {x:.6f}")
    pasos.append(f"   f(x) = {fx:.6f}")
    pasos.append(f"   f'(x) = {dfx:.6f}")
    pasos.append(f"   Nuevo valor x = {x_new:.6f}")

    historia.append((x, fx))

    if abs(x_new - x) < tol:
        pasos.append("✅ ¡Encontré la raíz aproximada!")
        x = x_new
        raiz = x
        break

    x = x_new
    pasos.append("--------------------------------------------------")

if 'raiz' not in locals() or raiz is None:
    pasos.append("❌ No se pudo encontrar la raíz en el número máximo de iteraciones")
    raiz = None
else:
    pasos.append(f"\\n🌈 La raíz aproximada es: x = {raiz:.6f}")
    pasos.append(f"f({raiz:.6f}) = {f(raiz):.6f}")

# Generar gráfica
img = ""
try:
    if raiz is not None and len(historia) > 0:
        # Crear un rango de valores para x
        x_vals = [h[0] for h in historia]
        x_min = min(x_vals + [raiz]) - 1
        x_max = max(x_vals + [raiz]) + 1
        
        x_range = np.linspace(x_min, x_max, 400)
        y_range = [f(x) for x in x_range]
        
        plt.figure(figsize=(10, 6))
        
        # Graficar la función
        plt.plot(x_range, y_range, label=f"f(x) = {f_str}", color="blue", linewidth=2)
        plt.axhline(0, color="black", linewidth=0.8)  # eje X
        
        # Graficar los puntos de la historia
        for i, (xi, fxi) in enumerate(historia, start=1):
            plt.plot(xi, fxi, "ro", markersize=6)
            plt.text(xi, fxi, f"{i}", fontsize=8, color="blue")
            
            # Dibujar línea tangente
            if i < len(historia):
                x_next = historia[i][0]
                # Calcular pendiente en xi
                m = df(xi)
                # Ecuación de la recta tangente: y = f(xi) + m*(x - xi)
                x_tangent = np.linspace(xi - 0.5, xi + 0.5, 50)
                y_tangent = fxi + m * (x_tangent - xi)
                plt.plot(x_tangent, y_tangent, 'r--', alpha=0.5, linewidth=1)
        
        # Marcar la raíz final
        plt.plot(raiz, f(raiz), 'go', markersize=8, label=f"Raíz: x ≈ {raiz:.4f}")
        
        plt.title("Método de Newton-Raphson - Paso a paso")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True, alpha=0.3)
        plt.legend()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
        plt.close()
except Exception as e:
    pasos.append(f"Nota: No se pudo generar la gráfica: {e}")

"\\n".join(pasos), img
          `;
        } else if (metodo === 'secante') {
          titulo = "Resultados - Método de la Secante";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# Función de entrada
f_str = """${funcion}"""
f = lambda x: eval(f_str, {"x": x, "np": np})

x0 = float("""${a}""")
x1 = float("""${b}""")
tol = float("""${tolerancia}""")
max_iter = 50

pasos = []

pasos.append("🌟 Bienvenido al método de la SECANTE 🌟")
pasos.append("Voy a buscar dónde la función se hace CERO (la raíz).")
pasos.append(f"Empezamos con: x0 = {x0}, x1 = {x1}")
pasos.append("--------------------------------------------------")

historia = []

for i in range(1, max_iter + 1):
    f0 = f(x0)
    f1 = f(x1)

    if f1 - f0 == 0:
        pasos.append("⚠️ Error: división por cero en la fórmula de la secante.")
        raiz = None
        break

    # Fórmula de la secante
    x2 = x1 - f1 * (x1 - x0) / (f1 - f0)

    pasos.append(f"🔹 Iteración {i}:")
    pasos.append(f"   x0 = {x0:.6f}, f(x0) = {f0:.6f}")
    pasos.append(f"   x1 = {x1:.6f}, f(x1) = {f1:.6f}")
    pasos.append(f"   Nuevo valor x2 = {x2:.6f}")

    historia.append((x1, f1))

    if abs(x2 - x1) < tol:
        pasos.append("✅ ¡Encontré la raíz aproximada!")
        x1 = x2
        raiz = x1
        break

    # Avanzamos los puntos
    x0, x1 = x1, x2

    pasos.append("--------------------------------------------------")

if 'raiz' not in locals() or raiz is None:
    pasos.append("❌ No se pudo encontrar la raíz en el número máximo de iteraciones")
    raiz = None
else:
    pasos.append(f"\\n🌈 La raíz aproximada es: x = {raiz:.6f}")
    pasos.append(f"f({raiz:.6f}) = {f(raiz):.6f}")

# Generar gráfica
img = ""
try:
    if raiz is not None and len(historia) > 0:
        # Crear un rango de valores para x
        x_vals = [h[0] for h in historia]
        x_min = min(x_vals + [raiz, x0]) - 1
        x_max = max(x_vals + [raiz, x0]) + 1
        
        x_range = np.linspace(x_min, x_max, 400)
        y_range = [f(x) for x in x_range]
        
        plt.figure(figsize=(10, 6))
        
        # Graficar la función
        plt.plot(x_range, y_range, label=f"f(x) = {f_str}", color="blue", linewidth=2)
        plt.axhline(0, color="black", linewidth=0.8)  # eje X
        
        # Graficar los puntos de la historia
        for i, (xi, fxi) in enumerate(historia, start=1):
            plt.plot(xi, fxi, "ro", markersize=6)
            plt.text(xi, fxi, f"{i}", fontsize=8, color="blue")
            
            # Dibujar línea secante
            if i < len(historia):
                x_prev = historia[i-1][0] if i > 1 else float("""${a}""")
                f_prev = historia[i-1][1] if i > 1 else f(float("""${a}"""))
                
                # Calcular pendiente de la secante
                m = (fxi - f_prev) / (xi - x_prev)
                # Ecuación de la recta secante: y = f(xi) + m*(x - xi)
                x_secante = np.linspace(min(x_prev, xi) - 0.5, max(x_prev, xi) + 0.5, 50)
                y_secante = fxi + m * (x_secante - xi)
                plt.plot(x_secante, y_secante, 'r--', alpha=0.5, linewidth=1)
        
        # Marcar la raíz final
        plt.plot(raiz, f(raiz), 'go', markersize=8, label=f"Raíz: x ≈ {raiz:.4f}")
        
        plt.title("Método de la Secante - Paso a paso")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True, alpha=0.3)
        plt.legend()
        
        buf = BytesIO()
        plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
        buf.seek(0)
        img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
        plt.close()
except Exception as e:
    pasos.append(f"Nota: No se pudo generar la gráfica: {e}")

"\\n".join(pasos), img
          `;
        }

        const [texto, img] = await pyodide.runPythonAsync(code);
        mostrarResultados(titulo, texto, img);
      } catch (err) {
        mostrarResultados("Error", 'Error: ' + err);
      }
    }

    // Función para calcular derivada numérica (ACTUALIZADA CON MÉTODO HACIA ATRÁS COMPLETO)
    async function calcularDerivada() {
      if (!pyodide) {
        alert("Pyodide aún se está cargando. Por favor, espera unos segundos.");
        return;
      }

      const funcion = document.getElementById('funcion-derivada').value;
      const a = document.getElementById('intervalo-a-derivada').value;
      const b = document.getElementById('intervalo-b-derivada').value;
      const n = document.getElementById('n-puntos-derivada').value;
      const metodo = document.getElementById('metodo-derivada').value;
      
      mostrarModal("Calculando...", "<p>Procesando la función y aplicando diferenciación numérica...</p>");

      try {
        let code;
        let titulo = "";
        
        if (metodo === 'adelante') {
          titulo = "Resultados - Diferenciación Numérica Hacia Adelante";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE DIFERENCIACIÓN NUMÉRICA HACIA ADELANTE ===

# Paso 1: Definir la función a derivar
def f(x):
    return ${funcion}  # Función proporcionada por el usuario

# Paso 2: Obtener parámetros del usuario
a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")

# Paso 3: Crear los puntos y calcular los valores de la función
x = np.linspace(a, b, n)
y = f(x)

# Paso 4: Calcular la derivada numérica por el método hacia adelante
h = x[1] - x[0]
dy_dx = np.zeros(n)
for i in range(n - 1):
    dy_dx[i] = (y[i + 1] - y[i]) / h
dy_dx[-1] = np.nan  # No se puede calcular en el último punto

# Paso 5: Mostrar resultados
resultados = []
resultados.append("=== RESULTADOS DEL MÉTODO HACIA ADELANTE ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}]")
resultados.append(f"Número de puntos: {n}")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append("x\\t\\tf(x)\\t\\tf'(x) aproximada")
resultados.append("-" * 50)
for i in range(n - 1):
    resultados.append(f"{x[i]:.4f}\\t\\t{y[i]:.4f}\\t\\t{dy_dx[i]:.4f}")
resultados.append(f"{x[-1]:.4f}\\t\\t{y[-1]:.4f}\\t\\tNo calculable")

# Paso 6: Graficar función y derivada
plt.figure(figsize=(10,5))
plt.plot(x, y, 'b-', label='f(x)', linewidth=2)
plt.plot(x, dy_dx, 'r--', label="Derivada hacia adelante f'(x)", linewidth=2)
plt.title("Diferenciación Numérica - Método Hacia Adelante")
plt.xlabel("x")
plt.ylabel("Valor")
plt.legend()
plt.grid(True)

# Guardar gráfica como imagen
buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        } else if (metodo === 'atras') {
          titulo = "Resultados - Diferenciación Numérica Hacia Atrás";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE DIFERENCIACIÓN NUMÉRICA HACIA ATRÁS ===

# Paso 1: Definir la función (puedes cambiarla)
def f(x):
    return ${funcion}

# Derivada exacta (para comparar)
def f_prime_exact(x):
    # Calcular derivada exacta usando sympy o manualmente
    # Para funciones comunes, definimos manualmente
    if "${funcion}" == "np.sin(x)":
        return np.cos(x)
    elif "${funcion}" == "np.cos(x)":
        return -np.sin(x)
    elif "${funcion}" == "np.exp(x)":
        return np.exp(x)
    elif "${funcion}" == "x**2":
        return 2*x
    elif "${funcion}" == "x**3":
        return 3*x**2
    else:
        # Para otras funciones, usar diferencia centrada como aproximación
        h_small = 1e-8
        return (f(x + h_small) - f(x - h_small)) / (2 * h_small)

# Paso 2: Parámetros del intervalo
a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")  # número de puntos

# Paso 3: Crear puntos y valores
x = np.linspace(a, b, n)
y = f(x)

# Paso 4: Calcular derivada hacia atrás
h = x[1] - x[0]
dy_dx = np.zeros(n)
dy_dx[0] = np.nan  # no se puede calcular en el primer punto
for i in range(1, n):
    dy_dx[i] = (y[i] - y[i - 1]) / h

# Paso 5: Derivada exacta y error
y_prime_exact = f_prime_exact(x)
error = np.abs(dy_dx - y_prime_exact)

# Paso 6: Mostrar resultados en algunos puntos
resultados = []
resultados.append("=== RESULTADOS DEL MÉTODO HACIA ATRÁS ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}]")
resultados.append(f"Número de puntos: {n}")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append(" x        f'(x) exacta     f'(x) numérica     error")
resultados.append("-" * 60)

# Mostrar algunos puntos representativos
indices_muestra = [1, 2, 10, min(50, n-1), min(98, n-1)]
for i in indices_muestra:
    if i < n:
        resultados.append(f"{x[i]:.4f}   {y_prime_exact[i]:.6f}          {dy_dx[i]:.6f}        {error[i]:.6f}")

# Paso 7: Graficar función y derivadas
plt.figure(figsize=(12, 8))

# Subplot 1: Función y derivadas
plt.subplot(2, 1, 1)
plt.plot(x, y, 'b-', label='f(x)', linewidth=2)
plt.plot(x, y_prime_exact, 'k-', label='Derivada exacta', linewidth=2)
plt.plot(x, dy_dx, 'r--', label="Derivada numérica (hacia atrás)", linewidth=2)
plt.title("Diferenciación Numérica - Método Hacia Atrás")
plt.xlabel("x")
plt.ylabel("Valor")
plt.legend()
plt.grid(True)

# Subplot 2: Error
plt.subplot(2, 1, 2)
plt.plot(x[1:], error[1:], 'm-', linewidth=2)
plt.title("Error absoluto |f'numérica - f'exacta| (Método Hacia Atrás)")
plt.xlabel("x")
plt.ylabel("Error absoluto")
plt.grid(True)

plt.tight_layout()

# Guardar gráfica como imagen
buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        } else if (metodo === 'centrada') {
          titulo = "Resultados - Diferenciación Numérica Centrada";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE DIFERENCIACIÓN NUMÉRICA CENTRADA ===

# Paso 1: Definir la función a derivar
def f(x):
    return ${funcion}  # Función proporcionada por el usuario

# Paso 2: Obtener parámetros del usuario
a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")

# Paso 3: Crear los puntos y calcular los valores de la función
x = np.linspace(a, b, n)
y = f(x)

# Paso 4: Calcular la derivada numérica por el método centrado
h = x[1] - x[0]
dy_dx = np.zeros(n)
dy_dx[0] = np.nan  # No se puede calcular en el primer punto
dy_dx[-1] = np.nan  # No se puede calcular en el último punto
for i in range(1, n - 1):
    dy_dx[i] = (y[i + 1] - y[i - 1]) / (2 * h)

# Paso 5: Mostrar resultados
resultados = []
resultados.append("=== RESULTADOS DEL MÉTODO CENTRADO ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}]")
resultados.append(f"Número de puntos: {n}")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append("x\\t\\tf(x)\\t\\tf'(x) aproximada")
resultados.append("-" * 50)
resultados.append(f"{x[0]:.4f}\\t\\t{y[0]:.4f}\\t\\tNo calculable")
for i in range(1, n - 1):
    resultados.append(f"{x[i]:.4f}\\t\\t{y[i]:.4f}\\t\\t{dy_dx[i]:.4f}")
resultados.append(f"{x[-1]:.4f}\\t\\t{y[-1]:.4f}\\t\\tNo calculable")

# Paso 6: Graficar función y derivada
plt.figure(figsize=(10,5))
plt.plot(x, y, 'b-', label='f(x)', linewidth=2)
plt.plot(x, dy_dx, 'r--', label="Derivada centrada f'(x)", linewidth=2)
plt.title("Diferenciación Numérica - Método Centrado")
plt.xlabel("x")
plt.ylabel("Valor")
plt.legend()
plt.grid(True)

# Guardar gráfica como imagen
buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        }

        const [texto, img] = await pyodide.runPythonAsync(code);
        mostrarResultados(titulo, texto, img);
      } catch (err) {
        mostrarResultados("Error", 'Error: ' + err);
      }
    }

    // Función para calcular integral numérica (ACTUALIZADA CON REGLA DEL TRAPECIO COMPLETA)
    async function calcularIntegral() {
      if (!pyodide) {
        alert("Pyodide aún se está cargando. Por favor, espera unos segundos.");
        return;
      }

      const funcion = document.getElementById('funcion-integral').value;
      const a = document.getElementById('limite-a').value;
      const b = document.getElementById('limite-b').value;
      const n = document.getElementById('n-integral').value;
      const metodo = document.getElementById('metodo-integral').value;
      
      mostrarModal("Calculando...", "<p>Procesando la función y aplicando integración numérica...</p>");

      try {
        let code;
        let titulo = "";
        
        if (metodo === 'trapecio') {
          titulo = "Resultados - Regla del Trapecio";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE INTEGRACIÓN NUMÉRICA: REGLA DEL TRAPECIO ===

# Paso 1: Definir la función (puedes cambiarla)
def f(x):
    return ${funcion}

# Función para calcular integral exacta (para comparar)
def integral_exacta(a, b):
    # Para funciones comunes, definimos manualmente la integral
    if "${funcion}" == "np.sin(x)":
        return -np.cos(b) + np.cos(a)
    elif "${funcion}" == "np.cos(x)":
        return np.sin(b) - np.sin(a)
    elif "${funcion}" == "np.exp(x)":
        return np.exp(b) - np.exp(a)
    elif "${funcion}" == "x**2":
        return (b**3 - a**3) / 3
    elif "${funcion}" == "x**3":
        return (b**4 - a**4) / 4
    else:
        # Para otras funciones, usar cuadratura adaptativa simple
        # Esta es una aproximación, no es exacta
        x_fine = np.linspace(a, b, 1000)
        y_fine = f(x_fine)
        return np.trapz(y_fine, x_fine)

# Paso 2: Ingreso de datos
a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")

# Paso 3: Crear puntos y valores
x = np.linspace(a, b, n + 1)
y = f(x)
h = (b - a) / n

# Paso 4: Aplicar la fórmula del trapecio
# I = h/2 * [f(x0) + 2Σf(xi) + f(xn)]
I = (h / 2) * (y[0] + 2 * np.sum(y[1:-1]) + y[-1])

# Paso 5: Comparar con la integral exacta
I_exact = integral_exacta(a, b)
error = abs(I - I_exact)

# Paso 6: Mostrar resultados
resultados = []
resultados.append("=== RESULTADOS REGLA DEL TRAPECIO ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}] con n = {n} subintervalos")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append(f"Valor aproximado: {I:.8f}")
resultados.append(f"Valor exacto:      {I_exact:.8f}")
resultados.append(f"Error absoluto:    {error:.2e}")
resultados.append("")
resultados.append("Fórmula aplicada:")
resultados.append(f"I = (h/2) * [f(x₀) + 2Σf(xᵢ) + f(xₙ)]")
resultados.append(f"  = ({h:.4f}/2) * [f({a:.4f}) + 2Σf(xᵢ) + f({b:.4f})]")
resultados.append(f"  = {I:.8f}")

# Paso 7: Graficar función y trapecios
x_plot = np.linspace(a, b, 200)
y_plot = f(x_plot)

plt.figure(figsize=(12, 8))

# Subplot 1: Función y área aproximada
plt.subplot(2, 1, 1)
plt.plot(x_plot, y_plot, 'b', label='f(x)', linewidth=2)
plt.fill_between(x, 0, y, color='orange', alpha=0.3, label='Área aproximada (Trapecio)')

# Dibujar los trapecios
for i in range(n):
    x_trap = [x[i], x[i+1], x[i+1], x[i]]
    y_trap = [0, 0, y[i+1], y[i]]
    plt.fill(x_trap, y_trap, 'orange', alpha=0.2)
    plt.plot([x[i], x[i]], [0, y[i]], 'k--', alpha=0.5, linewidth=0.8)
    plt.plot([x[i+1], x[i+1]], [0, y[i+1]], 'k--', alpha=0.5, linewidth=0.8)

plt.title("Integración Numérica - Regla del Trapecio")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)

# Subplot 2: Error por subintervalo
plt.subplot(2, 1, 2)
errores_por_intervalo = []
for i in range(n):
    # Calcular el área exacta del subintervalo
    area_exacta_sub = integral_exacta(x[i], x[i+1])
    # Calcular el área aproximada del subintervalo
    area_aprox_sub = (h / 2) * (y[i] + y[i+1])
    error_sub = abs(area_exacta_sub - area_aprox_sub)
    errores_por_intervalo.append(error_sub)

x_centros = [(x[i] + x[i+1]) / 2 for i in range(n)]
plt.bar(x_centros, errores_por_intervalo, width=h*0.8, alpha=0.7, color='red')
plt.title("Error por subintervalo")
plt.xlabel("x")
plt.ylabel("Error absoluto")
plt.grid(True, alpha=0.3)

plt.tight_layout()

# Guardar gráfica como imagen
buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        } else if (metodo === 'simpson13') {
          titulo = "Resultados - Regla de Simpson 1/3";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE INTEGRACIÓN NUMÉRICA: SIMPSON 1/3 ===

def f(x):
    return ${funcion}

a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")

# Verificar que n es par para Simpson 1/3
if n % 2 != 0:
    n = n + 1  # Hacer n par

x = np.linspace(a, b, n + 1)
y = f(x)
h = (b - a) / n

# Aplicar fórmula de Simpson 1/3
I = (h / 3) * (y[0] + y[-1] + 4 * np.sum(y[1:-1:2]) + 2 * np.sum(y[2:-1:2]))

resultados = []
resultados.append("=== RESULTADOS REGLA DE SIMPSON 1/3 ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}] con n = {n} subintervalos")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append(f"Valor aproximado: {I:.8f}")
resultados.append("")
resultados.append("Fórmula aplicada:")
resultados.append(f"I = (h/3) * [f(x₀) + f(xₙ) + 4Σf(x_impares) + 2Σf(x_pares)]")

# Graficar
x_plot = np.linspace(a, b, 200)
y_plot = f(x_plot)

plt.figure(figsize=(10, 6))
plt.plot(x_plot, y_plot, 'b-', label='f(x)', linewidth=2)
plt.fill_between(x, 0, y, color='green', alpha=0.3, label='Área aproximada (Simpson 1/3)')
plt.title("Integración Numérica - Regla de Simpson 1/3")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)

buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        } else if (metodo === 'simpson38') {
          titulo = "Resultados - Regla de Simpson 3/8";
          code = `
import numpy as np
import matplotlib.pyplot as plt
from io import BytesIO
import base64

# === MÉTODO DE INTEGRACIÓN NUMÉRICA: SIMPSON 3/8 ===

def f(x):
    return ${funcion}

a = float("""${a}""")
b = float("""${b}""")
n = int("""${n}""")

# Verificar que n es múltiplo de 3 para Simpson 3/8
if n % 3 != 0:
    n = n + (3 - n % 3)  # Hacer n múltiplo de 3

x = np.linspace(a, b, n + 1)
y = f(x)
h = (b - a) / n

# Aplicar fórmula de Simpson 3/8
I = (3 * h / 8) * (y[0] + y[-1] + 3 * np.sum(y[1:-1:3] + y[2:-1:3]) + 2 * np.sum(y[3:-1:3]))

resultados = []
resultados.append("=== RESULTADOS REGLA DE SIMPSON 3/8 ===")
resultados.append(f"Función: f(x) = ${funcion}")
resultados.append(f"Intervalo: [{a}, {b}] con n = {n} subintervalos")
resultados.append(f"Paso h: {h:.6f}")
resultados.append("")
resultados.append(f"Valor aproximado: {I:.8f}")
resultados.append("")
resultados.append("Fórmula aplicada:")
resultados.append(f"I = (3h/8) * [f(x₀) + f(xₙ) + 3Σ(f(x_{i+1}) + f(x_{i+2})) + 2Σf(x_{i+3})]")

# Graficar
x_plot = np.linspace(a, b, 200)
y_plot = f(x_plot)

plt.figure(figsize=(10, 6))
plt.plot(x_plot, y_plot, 'b-', label='f(x)', linewidth=2)
plt.fill_between(x, 0, y, color='purple', alpha=0.3, label='Área aproximada (Simpson 3/8)')
plt.title("Integración Numérica - Regla de Simpson 3/8")
plt.xlabel("x")
plt.ylabel("f(x)")
plt.legend()
plt.grid(True)

buf = BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = "data:image/png;base64," + base64.b64encode(buf.read()).decode()
plt.close()

"\\n".join(resultados), img
          `;
        }

        const [texto, img] = await pyodide.runPythonAsync(code);
        mostrarResultados(titulo, texto, img);
      } catch (err) {
        mostrarResultados("Error", 'Error: ' + err);
      }
    }

    // Funciones de cálculo para los otros métodos
    function calcularEDO() {
      const funcion = document.getElementById('funcion-edo').value;
      const condicion = document.getElementById('condicion-inicial').value;
      const x0 = document.getElementById('x-inicial').value;
      const xf = document.getElementById('x-final').value;
      const paso = document.getElementById('paso-edo').value;
      const metodo = document.getElementById('metodo-edo').value;
      
      const resultado = `Método: ${metodo.toUpperCase()}
EDO: dy/dx = ${funcion}
Condición inicial: y(${x0}) = ${condicion}
Intervalo: [${x0}, ${xf}]
Paso: h = ${paso}

Resultado simulado:
y(${xf}) ≈ 11.389

Este cálculo se ejecutaría con Python en el backend.`;
      
      mostrarResultados("Problemas de Valor Inicial - Resultados", resultado);
    }

    function ejecutarPython() {
      const codigo = document.getElementById('codigo-python').value;
      
      const resultado = `Código ejecutado (simulación):
${codigo}

--- SALIDA ---
[Gráfica generada - En un entorno real se mostraría la imagen]

Nota: En una implementación real, este código se enviaría a un servidor
con Python y matplotlib para generar las gráficas.`;
      
      mostrarResultados("Ejecución de Python - Resultados", resultado);
    }
  </script>
</body>
</html>
